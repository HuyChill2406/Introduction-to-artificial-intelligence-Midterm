# -*- coding: utf-8 -*-
"""8-puzzle.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1rpRKPEaF7Ea4ea2NVqg18BeQAeMAcgKd
"""

from collections import deque
from copy import deepcopy
import heapq
import matplotlib.pyplot as plt

#Calculate heuristic value based on Manhattan distance
#Between empty positions in three states a, b and c. The returned result is the sum of these distances
def heuristic(a, b, c):
    (x1, y1) = get_blank_pos_A_Star(a)
    (x2, y2) = get_blank_pos_A_Star(b)
    (x3, y3) = get_blank_pos_A_Star(c)
    return abs(x1 - x2) + abs(y1 - y2) + abs(x1 - x3) + abs(y1 - y3) + abs(x2 - x3) + abs(y2 - y3)

#Represents the row and column position of empty cells in the matrix
def get_blank_pos_A_Star(state):
    for i, row in enumerate(state):
        for j, col in enumerate(row):
            if col == 0:
                return i, j

#Returns the total cost and list of actions (A*)
def reconstruct_path(came_from, start, goal):
    current = goal
    path = []
    total_cost = 0
    while current != start:
        path.append(current.action)
        total_cost += 1  # assume each action has a cost of 1
        current = came_from[current.get_id()]
    path.reverse()  # reverse path to get actions from start to goal
    return total_cost, path

#Lớp Node
class Node:
    def __init__(self, state, action=None, parent=None, path_cost=0, priority=0):
        self.state = state
        self.id = ''.join(str(item) for sublist in state for item in sublist)  # Flatten the state and join into a string
        self.action = action
        self.parent = parent
        self.path_cost = path_cost
        self.priority = priority

    def __lt__(self, other):
        return self.priority < other.priority

    def __str__(self):
        represent_state = " "
        for row in self.state:
            for col in row:
                if col == 0:
                    represent_state += "_"
                else:
                    represent_state += str(col)
            represent_state += "\n"
        return represent_state

    def get_successors(self):
      list_of_successors_state = []
      list_actions = ["L", "R", "U", "D"]
      for action in list_actions:
          child_state = self.get_successor(action)
          if child_state is not None:
              child_path_cost = self.path_cost + 1  # Increase the path cost by 1
              list_of_successors_state.append(Node(child_state, action, self, path_cost=child_path_cost))
      return list_of_successors_state


    def get_successor(self, action):
        # Create a new copy of state
        state_copy = [list(row) for row in self.state]
        pi, pj = self.get_blank_pos(state_copy)
        if action == 'L' and pj > 0:
            state_copy[pi][pj], state_copy[pi][pj - 1] = state_copy[pi][pj - 1], state_copy[pi][pj]
        elif action == 'R' and pj < 2:
            state_copy[pi][pj], state_copy[pi][pj + 1] = state_copy[pi][pj + 1], state_copy[pi][pj]
        elif action == 'U' and pi > 0:
            state_copy[pi][pj], state_copy[pi - 1][pj] = state_copy[pi - 1][pj], state_copy[pi][pj]
        elif action == 'D' and pi < 2:
            state_copy[pi][pj], state_copy[pi + 1][pj] = state_copy[pi + 1][pj], state_copy[pi][pj]
        else:
            return None  # the action is not valid
        return state_copy

    def get_dest_pos(self, action, pi, pj):
        if action == 'L':
            pj += 1
        elif action == 'R':
            pj -= 1
        elif action == 'U':
            pi += 1
        elif action == 'D':
            pi -= 1
        return pi, pj

    def get_blank_pos(self, state):
        for i, row in enumerate(state):
            for j, col in enumerate(row):
                if col == 0:
                    return i, j

    def get_id(self):
        return self.id

    def get_node_str(self):
        return str(self)

    def get_action(self):
        return self.action

    def copy(self, new_path_cost):
        return Node(self.state, self.action, self.parent, new_path_cost, self.priority)

#thuật toán A*
def A_Star(start, goal,goal_state_2):
    frontier = []
    heapq.heappush(frontier, (0, start))
    came_from = {}
    cost_so_far = {}
    came_from[start.get_id()] = None
    cost_so_far[start.get_id()] = 0

    while frontier:
        (priority, current) = heapq.heappop(frontier)

        if current.state == goal.state or current.state == goal_state_2.state :
          return reconstruct_path(came_from, start, current)

        for next_state in current.get_successors():
            new_cost = cost_so_far[current.get_id()] + 1
            if next_state.get_id() not in cost_so_far or new_cost < cost_so_far[next_state.get_id()]:
                cost_so_far[next_state.get_id()] = new_cost
                priority = new_cost + heuristic(goal.state, next_state.state,goal_state_2.state)
                next_state.priority = priority
                heapq.heappush(frontier, (priority, next_state))
                came_from[next_state.get_id()] = current

    return None  # if no solution found

#thuật toán bfs
def bfs(initial_state, goal_state,goal_state_2):
    frontier = deque()  # FIFO queue
    start_node = initial_state.copy(0)
    frontier.append(start_node)
    explored = {start_node.get_id()}  # use id of start_node

    while frontier:
        node = frontier.popleft()
        if node.state == goal_state.state or node.state == goal_state_2.state :  # compare with goal_state.state
            actions = []
            total_cost = node.path_cost
            while node.parent is not None:
                actions.append(node.action)
                node = node.parent
            actions.reverse()
            return total_cost, actions  # return total path_cost and list of actions

        for child_node in node.get_successors():
            child_id = child_node.get_id()  # use id of child_node
            if child_id not in explored:
                explored.add(child_id)
                frontier.append(child_node)

    return None  # if no solution found

#Require the user to enter the matrix
def get_user_input():
    # Initialize an empty 3x3 matrix
    matrix = [[0, 0, 0] for _ in range(3)]

    for i in range(3):
        while True:
            row = input(f"Nhập vào hàng thứ {i+1} của ma trận (3 số từ 0 đến 8, không trùng lặp, cách nhau bởi dấu cách): ")
            numbers = row.split()

            # Check if the user input is valid
            if len(numbers) == 3 and len(set(numbers)) == 3 and all(0 <= int(num) <= 8 for num in numbers):
                matrix[i] = list(map(int, numbers))
                break
            else:
                print("Nhập không hợp lệ. Hãy thử lại.")

    return matrix

#Print the path from the initial state based on the list of actions
def print_path(start, actions):
    current_state = deepcopy(start.state)
    print("Start state:")
    print(start)
    for action in actions:
        pi, pj = get_blank_pos_A_Star(current_state)
        if action == 'L':
            current_state[pi][pj], current_state[pi][pj - 1] = current_state[pi][pj - 1], current_state[pi][pj]
        elif action == 'R':
            current_state[pi][pj], current_state[pi][pj + 1] = current_state[pi][pj + 1], current_state[pi][pj]
        elif action == 'U':
            current_state[pi][pj], current_state[pi - 1][pj] = current_state[pi - 1][pj], current_state[pi][pj]
        elif action == 'D':
            current_state[pi][pj], current_state[pi + 1][pj] = current_state[pi + 1][pj], current_state[pi][pj]
        print(f"After action {action}:")
        print(Node(current_state))

#choose algorithm and execute, print cost, action
algoritms = input("Hãy lựa chọn thuật toán bạn muốn (BFS/A*):")
if algoritms == 'A*':
  user_matrix = get_user_input()
  initial_state = Node(user_matrix)
  goal_state = Node([[1, 2, 3],[4, 5, 6],[7, 8, 0]])
  goal_state_2 = Node([[0, 1, 2],[3, 4, 5],[6, 7, 8]])
  result = A_Star(initial_state, goal_state,goal_state_2)
  if result is not None:
      total_cost_A_Star, actions_A_Star = result
      print(f"Total cost: {total_cost_A_Star}")
      print(f"Actions: {actions_A_Star}")
      print("Visualization of A*:")
      print_path(initial_state, actions_A_Star)
  else:
      print("No solution found.")
  print("Thực thi thuật toán BFS:")
  result = bfs(initial_state, goal_state,goal_state_2)
  if result is not None:
      total_cost_bfs, actions_bfs = result
      print(f"Total cost: {total_cost_bfs}")
      print(f"Actions: {actions_bfs}")
      print("Visualization of BFS:")
      print_path(initial_state, actions_bfs)
  else:
      print("No solution found.")

elif algoritms == 'BFS':
  user_matrix = get_user_input()
  initial_state = Node(user_matrix)
  goal_state = Node([[1, 2, 3],[4, 5, 6],[7, 8, 0]])
  goal_state_2 = Node([[0, 1, 2],[3, 4, 5],[6, 7, 8]])
  result = bfs(initial_state, goal_state,goal_state_2)
  if result is not None:
      total_cost_bfs, actions_bfs = result
      print(f"Total cost: {total_cost_bfs}")
      print(f"Actions: {actions_bfs}")
      print("Visualization of BFS:")
      print_path(initial_state, actions_bfs)
  else:
      print("No solution found.")
  print("Thực thi thuật toán A*:")
  result = A_Star(initial_state, goal_state,goal_state_2)
  if result is not None:
      total_cost_A_Star, actions_A_Star = result
      print(f"Total cost: {total_cost_A_Star}")
      print(f"Actions: {actions_A_Star}")
      print("Visualization of A*:")
      print_path(initial_state, actions_A_Star)
  else:
      print("No solution found.")

#Draw bar chart
avg_path_costs = {
    'BFS': total_cost_bfs,
    'A*': total_cost_A_Star
}

# Create bar chart
plt.bar(avg_path_costs.keys(), avg_path_costs.values(), color=['blue', 'green'])

plt.xlabel('Algorithms')
plt.ylabel('Total Path Cost')
plt.title('Comparison of Total Path Cost between BFS and A*')

# Display the plot
plt.show()

from collections import deque
from copy import deepcopy
import heapq
import matplotlib.pyplot as plt
import random

#Calculate heuristic value based on Manhattan distance
#Between empty positions in three states a, b and c. The returned result is the sum of these distances
def heuristic(a, b, c):
    (x1, y1) = get_blank_pos_A_Star(a)
    (x2, y2) = get_blank_pos_A_Star(b)
    (x3, y3) = get_blank_pos_A_Star(c)
    return abs(x1 - x2) + abs(y1 - y2) + abs(x1 - x3) + abs(y1 - y3) + abs(x2 - x3) + abs(y2 - y3)

#Represents the row and column position of empty cells in the matrix
def get_blank_pos_A_Star(state):
    for i, row in enumerate(state):
        for j, col in enumerate(row):
            if col == 0:
                return i, j

#Returns the total cost and list of actions (A*)
def reconstruct_path(came_from, start, goal):
    current = goal
    path = []
    total_cost = 0
    while current != start:
        path.append(current.action)
        total_cost += 1  # assume each action has a cost of 1
        current = came_from[current.get_id()]
    path.reverse()  # reverse path to get actions from start to goal
    return total_cost, path

#Node class
class Node:
    def __init__(self, state, action=None, parent=None, path_cost=0, priority=0):
        self.state = state
        self.id = ''.join(str(item) for sublist in state for item in sublist)  # Flatten the state and join into a string
        self.action = action
        self.parent = parent
        self.path_cost = path_cost
        self.priority = priority

    def __lt__(self, other):
        return self.priority < other.priority

    def __str__(self):
        represent_state = " "
        for row in self.state:
            for col in row:
                if col == 0:
                    represent_state += "_"
                else:
                    represent_state += str(col)
            represent_state += "\n"
        return represent_state

    def get_successors(self):
      list_of_successors_state = []
      list_actions = ["L", "R", "U", "D"]
      for action in list_actions:
          child_state = self.get_successor(action)
          if child_state is not None:
              child_path_cost = self.path_cost + 1  # Increase the path cost by 1
              list_of_successors_state.append(Node(child_state, action, self, path_cost=child_path_cost))
      return list_of_successors_state


    def get_successor(self, action):
        # Create a new copy of state
        state_copy = [list(row) for row in self.state]
        pi, pj = self.get_blank_pos(state_copy)
        if action == 'L' and pj > 0:
            state_copy[pi][pj], state_copy[pi][pj - 1] = state_copy[pi][pj - 1], state_copy[pi][pj]
        elif action == 'R' and pj < 2:
            state_copy[pi][pj], state_copy[pi][pj + 1] = state_copy[pi][pj + 1], state_copy[pi][pj]
        elif action == 'U' and pi > 0:
            state_copy[pi][pj], state_copy[pi - 1][pj] = state_copy[pi - 1][pj], state_copy[pi][pj]
        elif action == 'D' and pi < 2:
            state_copy[pi][pj], state_copy[pi + 1][pj] = state_copy[pi + 1][pj], state_copy[pi][pj]
        else:
            return None  # the action is not valid
        return state_copy

    def get_dest_pos(self, action, pi, pj):
        if action == 'L':
            pj += 1
        elif action == 'R':
            pj -= 1
        elif action == 'U':
            pi += 1
        elif action == 'D':
            pi -= 1
        return pi, pj

    def get_blank_pos(self, state):
        for i, row in enumerate(state):
            for j, col in enumerate(row):
                if col == 0:
                    return i, j

    def get_id(self):
        return self.id

    def get_node_str(self):
        return str(self)

    def get_action(self):
        return self.action

    def copy(self, new_path_cost):
        return Node(self.state, self.action, self.parent, new_path_cost, self.priority)

#A* algorithm
def A_Star(start, goal,goal_state_2):
    frontier = []
    heapq.heappush(frontier, (0, start))
    came_from = {}
    cost_so_far = {}
    came_from[start.get_id()] = None
    cost_so_far[start.get_id()] = 0

    while frontier:
        (priority, current) = heapq.heappop(frontier)

        if current.state == goal.state or current.state == goal_state_2.state :
          return reconstruct_path(came_from, start, current)

        for next_state in current.get_successors():
            new_cost = cost_so_far[current.get_id()] + 1
            if next_state.get_id() not in cost_so_far or new_cost < cost_so_far[next_state.get_id()]:
                cost_so_far[next_state.get_id()] = new_cost
                priority = new_cost + heuristic(goal.state, next_state.state,goal_state_2.state)
                next_state.priority = priority
                heapq.heappush(frontier, (priority, next_state))
                came_from[next_state.get_id()] = current

    return None  # if no solution found

#bfs algorithm
def bfs(initial_state, goal_state,goal_state_2):
    frontier = deque()  # FIFO queue
    start_node = initial_state.copy(0)
    frontier.append(start_node)
    explored = {start_node.get_id()}  # use id of start_node

    while frontier:
        node = frontier.popleft()
        if node.state == goal_state.state or node.state == goal_state_2.state :  # compare with goal_state.state
            actions = []
            total_cost = node.path_cost
            while node.parent is not None:
                actions.append(node.action)
                node = node.parent
            actions.reverse()
            return total_cost, actions  # return total cost and list of actions

        for child_node in node.get_successors():
            child_id = child_node.get_id()  # use id of child_node
            if child_id not in explored:
                explored.add(child_id)
                frontier.append(child_node)

    return None  # if no solution found

#randomly generate 1000 states (3x3 matrix according to 8_puzzle game)
def generate_random_state():
    numbers = list(range(9))  # numbers from 0 to 8
    random.shuffle(numbers)  # shuffle the numbers
    return [numbers[i*3:(i+1)*3] for i in range(3)]  # split into 3x3 matrix

random_states = [Node(generate_random_state()) for _ in range(1000)]

goal_state = Node([[1, 2, 3], [4, 5, 6], [7, 8, 0]])
goal_state_2 = Node([[0, 1, 2], [3, 4, 5], [6, 7, 8]])

total_cost_bfs = 0
total_cost_A_Star = 0
possible_solution_bfs = 0
possible_solution_A_Star = 0

# Perform BFS and A* for each state in random_states
for state in random_states:
    result_bfs = bfs(state, goal_state,goal_state_2)
    result_a_star = A_Star(state, goal_state,goal_state_2)
    if result_bfs is None and result_a_star is None:
      continue
    if result_bfs is not None:
        possible_solution_bfs += 1
        cost_bfs, actions_bfs = result_bfs
        print(f"Total Cost Of One State To Goal State (BFS): {cost_bfs} ")
        print(f"List Actions Of One State To Goal State (BFS): {actions_bfs}")
        total_cost_bfs += result_bfs[0]
    if result_a_star is not None:
        possible_solution_A_Star += 1
        cost_a_star, actions_a_star = result_a_star
        print(f"Total Cost Of One State To Goal State (A*): {cost_a_star} ")
        print(f"List Actions Of One State To Goal State (A*): {actions_a_star}")
        total_cost_A_Star += result_a_star[0]
    print("-------------------------------------------------------------------------------------------------------------")

# Calculate the average costs
print(f"Total Possible Solution of BFS: {possible_solution_bfs}")
print(f"Total Possible Solution of A*: {possible_solution_A_Star}")
average_cost_bfs = total_cost_bfs / possible_solution_bfs
average_cost_A_Star = total_cost_A_Star / possible_solution_A_Star
print(f"Giá Trị Trung Bình Của BFS: {average_cost_bfs}")
print(f"Giá Trị Trung Bình Của A*: {average_cost_A_Star}")

#Draw the bar chart
avg_path_costs = {
    'BFS': average_cost_bfs,
    'A*': average_cost_A_Star
}
# Create bar chart
plt.bar(avg_path_costs.keys(), avg_path_costs.values(), color=['blue', 'green'])
plt.xlabel('Algorithms')
plt.ylabel('Average Path Cost')
plt.title('Comparison of Average Path Cost between BFS and A*')
# Display the plot
plt.show()

#Draw the bar chart
total_num_solutions = {
    'BFS': possible_solution_bfs,  # replace with actual value
    'A*': possible_solution_A_Star  # replace with actual value
}
# Create bar chart
plt.bar(total_num_solutions.keys(), total_num_solutions.values(), color=['blue', 'green'])
plt.xlabel('Algorithms')
plt.ylabel('Number_Possible_Solutions')
plt.title('Comparison of Number Possible Solutions between BFS and A*')
# Display the plot
plt.show()